# LearningJavaScript-1회차 

```md
**정리한 목차**

1. 첫 번쨰 애플리케이션
1. 자바스크립트 개발 도구
1. 리터럴과 변수, 상수, 데이터 타입

```

## 01. 첫번쨰 애플리케이션 

**문법 하이라이트**
문법 하이라이트 기능은 프로그램의 문법적 요소를 색깔로 구별하는 기능 

**괄호 맟추기**
괄호는 반드시 짝이 맞아야하며 맞지 않으면 프로그램이 정확히 동작하지 않음 

**코드 접기**
괄호 기능과 관련, 하고 있는 작업과 무관한 코드는 임시적으로 숨겨놓은 기능 

**자동 완성**
단어 일부를 타이핑하기만 해도 어떤 단어를 타이핑하려 했는지 짐작 및 제시 -`단어완성`, `인텔리센스` 

**주석**
자바스크립트에서는 주석을 완전 무시합니다. 주석은 미래의 나 또는 동료들을 위해 작성합니다.

> 🔖 `use strict` 엄격모드
> 자바스크립트 인터프리터에서 코드를 더 업격하게 처리하는 뜻입니다. 
> 엄격 모드를 선언하면 해당 파일 전체가 엄격 모드로 동작하고, 함수 위에서 선언한다면 해당 함수만 엄격 모드로 동작합니다. 
> **ES2015 모듈을 이용해 작성된 코드는 항상 엄격 모드로 동작하기 때문에, 함수 위에 'use strict';를 붙여주지 않아도 엄격 모드로 동작합니다.**


**자바스크립트 개발 도구** 

* Git: 큰 프로젝트도 관리가 쉽고 다른 개발자와 협력할 수 있게 돕는 버전 컨트롤 도구 
* Node:  브라우저 밖에서 자바스크립트를 실행할 수 있게 하는 도구,  npm은 이 리스트의 다른 도구를 설치할 떄 필요
* Gulp: 반복적인 개발 작업을 자동화하는 빌드 도구 
* Babel: ES6코드를 ES5로 변환하는 트랜스컴파일러
* ESLint: 자주 하는 실수를 피하고 더 나은 프로그래머가 되도록 도움 

### 1. ES06 (ES2015)

자바스크립트는 인터프리팅 언어이고 번거로운 부대 작업이 필요 없다는 장점이 있습니다.
-> 노드 같은 자바스크립트 엔진은 분명 자바스크립트를 컴파일하긴 하지만, 프로그래머가 개입할 필요 없이 자동으로 이루어집니다. 

**자바스크립트의 장점**
1. 어디서든 쓰인다
1. 항상 브라우저 스크립트 언의 표준
1. 노드의 등장으로 이제 브라우저 바깥으로 영역 확대

ES06의 훌륭한 기능을 모두 지원할 때까지는 시간이 걸리게 때문에 트랜스컴파일([Babel](https://babeljs.io/))을 피할 수 없습니다.

뉴욕 개발자 캉각스는 ES06의 기능별 호환성 테이블을 운영 [kangax](https://kangax.github.io/compat-table/es6/)


### 1-2. [Git](https://git-scm.com/)

### 1-3. 터미널 

가장 많이 사용하는 배시(bash)라는 셸입니다. 
|리눅스|MacOS|윈도우|
|---|---|---|
|셸|셸|터미널(윈도우는 Git Bash 다운)|


**터미널 명령어**
```js
// 파일 리스트 보기
$ ls

// 홈 디레터리
$ cd ~

// 현재 디렉터리 경로 출력
$ pwd

// 새 디렉터리 만들기 
$ mkdir 파일명

// 디렉터리 이동
$ cd 파일명

// 한 단계 위 디렉더리
$ cd ..
```

> 🏷Tip
> 프로젝트마다 디렉터리를 따로 만드는게 좋습니다. 
> 이 디렉터리를 프로젝트 `루트`라고 부릅니다. 

### 1-4. git 

```js 
// 저장소 만들기
$ git init

//  저장소의 현재 상태출력
$ git status

// 파일이 아니라 변경사항을 추가
$ git add
```

[참고하세요!!!](https://try.github.io/)

### 1-5. npm 패키지 관리 

노드개발에서  npm은 필수 !!!
npm을 통해 빌드 도구와 트랜스컴파일러를 설치합니다.
npm은 패키지를 설치할 때 전역(globally) 또는 로컬(locally)설치할 수 있습니다. 

- 터미널에서 실행하는 도구, 개발과정에서 사용: 전역으로 설치하는 패키지(globally)
- 프로젝트에 종속되는 패키지: 로컬(locally)

설치하는 모듈이 늘어나면 모듈을 추적하고 관리할 방법이 필요합니다. 프로젝트에 설치하고 사용하는 모듈을 `의존성`이라고 부릅니다.  프로젝트가 성장하면서 늘어날 필요 패키지를 간결하게 정리할 방법이 있으면 좋습니다. 
npm은 package.json파일을 통해 의존석을 관리합니다.

- 개발의존성: 앱을 실행할 때는 필요없지만, 프로젝트 개발할 때 필요하거나 도움이 되는 패키지입니다. 


### 1-6, 빌드 도구: 걸프와 그런트 

반복작업을 자동화하는 빌드 도구 -> 그런트와 걸프 

```js
//설치
$npm install -g gulp
```

### 1-7. 프로젝트 구조 

```
# Git
.git
.gitignore

# npm
package.json
node_modules

# 노드소스
es6
dist

# 브라우저 소스
.public/
├── es6/
└── dist/

```

## 2. 트랜스컴파일러

트랜스컴파일러는 바벨과 트레이서입니다. 
바벨: ES5-> ES6로 바꾸는 트랜스컴파일러로 시작하였고 프로젝트가 성장하면서 ES6와 react, ES7 등 여러가지를 지원하는 범용 크랜드컴파일러가 됐습니다.

```js
$ npm install --save-dev babel-preset-es2015
```

### 2-1. 바벨과 걸프 함께 사용

ES6 코드를 ES5 코드로 바뀔때 사용 
걸프는 파이프라인 개념으로 작업을 처리합니다. 

### 3. 린트 

린트 프로그램은 당신의 코드를 세심히 검토해서 자주 일어나느 실수를 알려줍니다. 

```js
npm install -g eslint

// .eslintrc 생섬 및 스타일 가이드 설정 질문이 나옴 
eslint --init
```

Gulpgile에는 ESLint를 꼭 추가하길 권합니다. 빌드 할때 마다 걸프를 실행하므로 여기서 코드를 체크하는 것이 좋습니다.

```js
npm install --save-dev gulp-eslint
```

[ESLint](https://eslint.org/)에는 설정 옵션이 아주 많으며, 해당 사이트에 문서화되어 있습니다. 확인하세요

## 3. 리터럴과 변수, 상수, 데이터 타입

변수와 상수 리터럴은 자바스크립트가 데이터를 보관하는 메커니즘 

### 3-1. 변수와 상수 

**변수** 
* 이름이 붙은 값, 언제든 바꿀수 있는 값
* 선언(생성)하고 초기값을 할당하는 두 가지 일을 함 
* 선언만 해도 에러가 나지 않습니다.
* 변수를 선언할때 초깃값을 지정하지 않으면 `undefined`
* let문 하나에 변수 여러 개를 선언 

```js
let currrentTempC = 22;
```

**상수**
* 선언(생성)을 가능하지만 재대입은 불가능
* 선언할 때는 반드시 값을 대입
* 상수 여러개를 선언 가능 
* 상수 이름은 보통 대문자와 밑줄만 사용 


```js
const currrentTempC = 22;
```

> 항상 let 보다 const를 사용하는 것이 좋습니다. let을 사용하면 의도치 않게 다른 값이 대입되어 버리는 일이 생길 수 있기 때문입니다. 정말로 재대입이 필요한 경우에만 let을 사용하는 것이 좋은 습관입니다.

### 3-2. 식별자 

변수와 상수, 함수 이름을 식별자라 부릅니다. 

* 숫자, 알파벳, 달러 문자($), 언더스코어(_)가 포함될 수 있다.
* 단, 숫자로 시작되어서는 안 된다.
* 예약어는 식별자가 될 수 없다.

```js
const foo; // O
const _bar123; // O
const $; // O - jQuery가 이 식별자를 사용합니다.
const 7seven; // X
const const; // X - 예약어는 식별자가 될 수 없습니다.
```

**Camel case**
JavaScript에서 널리 사용되는 관례
```js
// Camel case
let fastCampus;
let fooBar;
```

**Snake case**
JavaScript에서는 잘 사용되지 않고, Python 등의 프로그래밍 언어에서 많이 사용
```js
// Snake case
let fast_campus;
let foo_bar;
```

### 3-3. 리터럴

리터럴이라는 단어는 값을 프로그램 안에서 직접 지정한다는 의미
리터럴은 값을 만드는 방법 

```js
1; // 정수 리터럴
2.5; // 부동 소수점 리터럴
'hello'; // 문자열 리터럴
true; // 진리값 리터럴
```
### 3-4. 원시 타입과 객체

|원시타입|참조타입|
|---|---|
|Boolean|Object|
Null6| |
Undefined| |
Number| |
String| |
Symbol| |

![](https://t1.daumcdn.net/cfile/tistory/9968C8405C2704C702)

Primitive Type(기본형) : 값을 그대로 할당

변수에 할당 -> 데이터가 비어있는 주소를 찾아서 데이터 할당 -> 같은 변수에 할당

-> 해당 변수가 가지고있는 주소로 가서 데이터 할상


![](https://t1.daumcdn.net/cfile/tistory/99B207405C2704C635)


Reference Type(참조형) : 참조된 주소를 할당

선언 -> 할당 -> 데이터에 객체정보 주소와 저장 -> 해당 주소의 데이터 안에 객체정보 주소와 저장 -> 해당 주소의 온전한 데이터들을 할당

### 3-5. 숫자

자바스크립트도 다른 프로그래밍 언너와 마찬가지로 실제 숫자의 근사치를 저장할 때 IEEE-764 배정도 부동소수점 숫자 형식을 사용합니다. 

자바스크립트에는 숫자형 데이터 타입이 하나밖에 없습니다. 대부분의 프로그래밍 언어는 여러가지 정수 타입을 사용하며 부동소수점 숫자 타입도 두가지 이상 사용합니다. 

> 🚧 숫자를 작성할때 따옴표를 쓰지 마십시오

```js
7; // 정수 리터럴
2.5; // 부동 소수점 리터럴
0b111; // 2진수 리터럴 (binary literal)
0o777; // 8진수 리터럴 (octal literal)
0xf5; // 16진수 리터럴 (hexademical literal)

NaN //계산 불가능한 연산의 결과값
-0 // 0과 같은 값으로 간주
Infinity //무한 
-Infinity
```

**NaN**

유일하게 자신과 같지 않은 값지 않은 값입니다. 
판별하기 위해서는 `Number.isNaN` 또는 `Object.is` 함수를 사용합니다. 

```js
const thisIsNan = NaN;

// 주의! 이렇게 하면 안 됩니다.
thisIsNan === NaN; // false

// 이렇게 해야 합니다.
Number.isNaN(thisIsNan); // true
Object.is(thisIsNan, NaN); // true
```

**-0**

`0`과 `-0`은 별개의 값이지만 비교연산은 하면 `true`
그러나 예외 존재 합니다. `Object.is` 함수는 `0`과 `-0`을 다른값으로 취급합니다. 
그리고 0이 아닌 어떤수를 `0` 혹은 `-0`으로 나눌 때에도 결과값이 다릅니다.

```js
0 === -0; // true
Object.is(0, -0); // false
1 / 0; // Infinity
1 / -0; // -Infinity
```

**Infinity**
어떤 값이 `Infinity`인지 아닌지 판별하려면, `Number.isFinite` 메소드를 사용
```js
Number.isFinite(1); // true
Number.isFinite(Infinity); // false
Number.isFinite('1'); // false
isFinite('1'); // true - `isFinite`는 문자열을 숫자로 변환합니다.
```



### 3-6. 문자열 

자바스크립트 문자열은 유니코드텍스트입니다. 
자바스크립트의 문자열 리터럴에는 작은따옴표, 큰따옴표, 백틱을 사용

필자는 ""을 사용 이유는 don't등의 아포스트로피를 더 많이 쓰는편이기 떄문 




### 3-7. 템플릿 리터럴 

``` js
const name1 = 'Foo';
const name2 = 'Bar';
const sentence = `${name1} meets ${name2}!`;
console.log(sentence);

// 일반적인 문자열 리터럴로는 아래와 같이 해야 합니다.
name1 + ' meets ' + name2 + '!';
```